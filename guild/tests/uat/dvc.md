# DvC support

These tests make use of the `dvc` example.

This project is used as a template for a working DvC repo. We run
`setup.py` to generate a project we can work with.

    >>> tmp = mkdtemp()
    >>> cd(example("dvc"))
    >>> run("python setup.py '%s'" % tmp)
    Initializing ...
    Initializing Git
    Initializing DvC
    Copying source code files
    <exit 0>

    >>> cd(tmp)

    >>> run("guild ops")  # doctest: +REPORT_UDIFF
    eval-models-dvc-stage      Use Guild DvC plugin to run eval-models stage
    hello-dvc-dep              Uses DvC dependency to fetch required file if needed
    hello-dvc-dep-always-pull  Uses DvC dependency to always fetch required file
    hello-dvc-stage            Uses Guild DvC plugin to run hello stage
    hello-guild-dep            Standard Guild dependency example without DvC support
    prepare-data-dvc-stage     Use Guild DvC plugin to run prepare-data stage
    train-models-dvc-stage     Use Guild DvC plugin to run train-models stage
    <exit 0>

## DvC resource sources

The dvc plugin adds support for a 'dvc' source type. This is used in
the sample project's 'hello-dvc-dep' operation.

The 'dvc' source type acts like a 'file' source when the specified
file is available.

    >>> write("hello.in", "Project File")

    >>> run("guild run hello-dvc-dep -y")
    Resolving dvc:hello.in dependency
    Hello Project File!
    <exit 0>

If the file isn't available, Guild uses 'dvc pull' to fetch it.

    >>> rm("hello.in")

    >>> run("guild run hello-dvc-dep -y")
    Resolving dvc:hello.in dependency
    Fetching DvC resource hello.in
    A       hello.in
    1 file added and 1 file fetched
    Hello World!
    <exit 0>

In this case, Guild copies 'hello.in.dvc' to the run directory from
the project directory. This is in turn used by 'dvc pull' to fetch
'hello.in' from remote storage.

    >>> run("guild ls -n")
    hello.in
    hello.in.dvc
    hello.out
    <exit 0>

Remote storage is defined in the project file 'dvc.config.in'. This is
a special file that Guild uses to initialize the DvC repo.

    >>> cat(join_path(tmp, "dvc.config.in"))
    [core]
        analytics = false
        remote = guild-pub
    ['remote "guild-pub"']
        url = https://guild-pub.s3.amazonaws.com/dvc-store
    ['remote "guild-s3"']
        url = s3://guild-pub/dvc-store

    >>> run("guild cat -p .dvc/config")
    [core]
        analytics = false
        remote = guild-pub
    ['remote "guild-pub"']
        url = https://guild-pub.s3.amazonaws.com/dvc-store
    ['remote "guild-s3"']
        url = s3://guild-pub/dvc-store
    <exit 0>

A DvC dependency can always be pulled by setting 'always-pull' to true
in the Guild file. The operation 'hello-dvc-dep-always-pull'
illustrates this.

Provide 'hello.in' in the project directory.

    >>> write("hello.in", "Ignored Local File")
    >>> run("guild run hello-dvc-dep-always-pull -y")
    Resolving dvc:hello.in dependency
    Fetching DvC resource hello.in
    A       hello.in
    1 file added and 1 file fetched
    Hello World!
    <exit 0>

## Use of `guild.plugins.dvc_stage_main`

The module `guild.plugins.dvc_stage_main` can be used to run a stage
defined in dvc.yaml.

These operations use this module as their `main` attr:

- prepare-data-dvc-stage
- train-models-dvc-stage
- eval-models-dvc-stage

Guild handles dependency resolution from this module as follows:

- Dependencies that are resolved from the project are copied from the
  project dir (if present) or pulled using the DvC config file for the
  dependency.

- Dependencies that are generated by upstream stages are resolved by
  looking for Guild operations for those stages. Such operation are
  designated by a `dvc-stage` run attribute matching the upstream
  stage name.

To illustrate, we first delete existing runs.

    >>> quiet("guild runs rm -y")

Try to run operations that requires an upstream stage.

    >>> run("guild run train-models-dvc-stage -y")
    INFO: [guild] Running DvC stage train-models
    INFO: [guild] Initializing run
    INFO: [guild] Copying train_models.py
    guild: no suitable run for stage 'prepare-data' (needed for iris.npy)
    <exit 1>

    >>> run("guild run eval-models-dvc-stage -y")
    INFO: [guild] Running DvC stage eval-models
    INFO: [guild] Initializing run
    INFO: [guild] Copying eval_models.py
    guild: no suitable run for stage 'prepare-data' (needed for iris.npy)
    <exit 1>

Run op required for 'prepare-data'.

    >>> run("guild run prepare-data-dvc-stage -y")  # doctest: +REPORT_UDIFF
    INFO: [guild] Running DvC stage prepare-data
    INFO: [guild] Initializing run
    INFO: [guild] Fetching iris.csv
    INFO: [guild] Fetching DvC resource iris.csv
    A       iris.csv
    1 file added and 1 file fetched
    INFO: [guild] Copying prepare_data.py
    Running stage 'prepare-data':
    > python prepare_data.py
    Saving iris.npy
    Generating lock file 'dvc.lock'
    Updating lock file 'dvc.lock'
    ...
    <exit 0>

This resolved the required file 'iris.csv' by pulling from the remote
storage.

    >>> run("guild ls -n")  # doctest: +REPORT_UDIFF
    dvc.lock
    dvc.yaml
    iris.csv
    iris.csv.dvc
    iris.npy
    prepare_data.py
    <exit 0>

With the 'prepare-data' operation, we can run 'train-models'.

    >>> run("guild run train-models-dvc-stage -y")  # doctest: +REPORT_UDIFF
    INFO: [guild] Running DvC stage train-models
    INFO: [guild] Initializing run
    INFO: [guild] Copying train_models.py
    INFO: [guild] Using ... for 'prepare-data' DvC stage dependency
    INFO: [guild] Linking iris.npy
    INFO: [guild] Copying params.json.in
    Running stage 'train-models':
    > python train_models.py
    Using C=1.000000
    Saving model-1.joblib
    Saving model-2.joblib
    Saving model-3.joblib
    Saving model-4.joblib
    Generating lock file 'dvc.lock'
    Updating lock file 'dvc.lock'
    ...
    <exit 0>

    >>> run("guild ls -n")  # doctest: +REPORT_UDIFF
    dvc.lock
    dvc.yaml
    iris.npy
    model-1.joblib
    model-2.joblib
    model-3.joblib
    model-4.joblib
    params.json.in
    train_models.py
    <exit 0>

And with 'train-models' and 'prepare-data', we can run 'eval-models'.

    >>> run("guild run eval-models-dvc-stage -y")  # doctest: +REPORT_UDIFF
    INFO: [guild] Running DvC stage eval-models
    INFO: [guild] Initializing run
    INFO: [guild] Copying eval_models.py
    INFO: [guild] Using ... for 'prepare-data' DvC stage dependency
    INFO: [guild] Linking iris.npy
    INFO: [guild] Using ... for 'train-models' DvC stage dependency
    INFO: [guild] Linking model-1.joblib
    INFO: [guild] Linking model-2.joblib
    INFO: [guild] Linking model-3.joblib
    INFO: [guild] Linking model-4.joblib
    Running stage 'eval-models':
    > python eval_models.py
    Saving models-eval.json
    Saving models-eval.png
    Generating lock file 'dvc.lock'
    Updating lock file 'dvc.lock'
    ...
    <exit 0>

    >>> run("guild ls -n")  # doctest: +REPORT_UDIFF
    dvc.lock
    dvc.yaml
    eval_models.py
    iris.npy
    model-1.joblib
    model-2.joblib
    model-3.joblib
    model-4.joblib
    models-eval.json
    models-eval.png
    <exit 0>
