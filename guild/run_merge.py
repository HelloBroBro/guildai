# Copyright 2017-2022 RStudio, PBC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from collections import namedtuple

import errno
import fnmatch
import os
import shutil

from guild import file_util
from guild import run_manifest


class MergeError(Exception):
    pass


class StopMerge(Exception):
    """Raised during a merge to indicate the operation stopped early."""

    def __init__(self, target_file, msg=None):
        super(StopMerge, self).__init__([target_file, msg])
        self.target_file = target_file
        self.msg = msg


RunMerge = namedtuple(
    "RunMerge",
    [
        "run",
        "copy_all",
        "skip_sourcecode",
        "skip_deps",
        "exclude",
        "to_copy",
        "to_skip",
    ],
)

CopyFile = namedtuple(
    "MergeFile",
    [
        "file_type",
        "run_path",
        "target_path",
    ],
)
CopyFile.__doc__ = """
Represents a merge file to be copied.

`file_type` is one of:

  s - source code file
  d - project-local dependency source
  o - 'other' file - i.e. a non-source and not a dependency, likely
      generated by the run
"""

SkipFile = namedtuple(
    "SkipFile",
    [
        "reason",
        "run_path",
        "target_path",
    ],
)
SkipFile.__doc__ = """
Represents a merge file that is skipped rather than copied.

`reason` is a code indicating why the file is skipped.

  x   - path matches a user-provided exclude pattern
  s   - user opted to skip source code files
  d   - user opted to skip dependencies
  npd - file is a non-project dependencies (either from a non-project
        location or from a project-local unpacked archive)
  u   - file from manifest is unknown (not a source code file or
        dependency source)
"""

_ManifestEntry = namedtuple(
    "_ManifestEntry",
    [
        "file_type",
        "run_path",
        "file_hash",
        "source",
        "source_subpath",
    ],
)


def init_run_merge(
    run,
    copy_all=False,
    skip_sourcecode=False,
    skip_deps=False,
    exclude=None,
    prefer_nonsource=False,
):
    manifest_index = _init_manifest_index(run)
    merge = RunMerge(
        run,
        copy_all=copy_all,
        skip_sourcecode=skip_sourcecode,
        skip_deps=skip_deps,
        exclude=exclude,
        to_copy=[],
        to_skip=[],
    )
    _apply_run_files_to_merge(run, manifest_index, merge)
    return merge


def _init_manifest_index(run):
    """Returns a lookup table keyed by run path containing _ManifestEntry items."""
    try:
        m = run_manifest.manfiest_for_run(run)
    except FileNotFoundError:
        raise MergeError(f"run manifest does not exist for run {run.id}")
    else:
        return {args[1]: _manifest_index_entry(args, run) for args in m}


def _manifest_index_entry(args, run):
    if len(args) not in (4, 5):
        raise MergeError(f"unexpected manfiest entry for run {run.id}: {args}")
    file_type = args[0]
    run_path = args[1]
    file_hash = args[2]
    source = args[3]
    source_subpath = args[4] if len(args) == 5 else None
    return _ManifestEntry(file_type, run_path, file_hash, source, source_subpath)


def _apply_run_files_to_merge(run, manifest_index, merge):
    for path in _iter_run_files(run):
        _apply_run_file_to_merge(path, manifest_index, merge)


def _iter_run_files(run):
    for path in file_util.find(
        run.dir, followlinks=True, includedirs=True, unsorted=True
    ):
        full_path = os.path.join(run.dir, path)
        if os.path.isfile(full_path):
            yield path


def _apply_run_file_to_merge(path, manifest_index, merge):
    manifest_entry = manifest_index.get(path)
    if manifest_entry:
        _apply_manifest_entry_to_merge(manifest_entry, merge)
    else:
        _apply_unknown_file_to_merge(path, merge)


def _apply_manifest_entry_to_merge(entry, merge):
    if entry.file_type == "s":
        _apply_sourcecode_entry_to_merge(entry, merge)
    elif entry.file_type == "d":
        _apply_dep_entry_to_merge(entry, merge)
    else:
        log.warning(
            "unknown manifest file type '%s' for run file %s",
            entry.file_type,
            entry.run_path,
        )
        _skip_unknown(entry.run_path, merge)


def _apply_sourcecode_entry_to_merge(entry, merge):
    if merge.skip_sourcecode:
        _skip_sourcecode_entry(entry, merge)
    elif _is_excluded_path(entry.source, merge):
        _skip_excluded(entry.run_path, entry.source, merge)
    else:
        _copy_sourcecode_entry(entry, merge)


def _skip_sourcecode_entry(entry, merge):
    merge.to_skip.append(SkipFile("s", entry.run_path, entry.source))


def _is_excluded_path(path, merge):
    if not merge.exclude:
        return False
    return any(fnmatch.fnmatch(path, pattern) for pattern in merge.exclude)


def _skip_excluded(run_path, target_path, merge):
    merge.to_skip.append(SkipFile("x", run_path, target_path))


def _copy_sourcecode_entry(entry, merge):
    merge.to_copy.append(CopyFile("s", entry.run_path, entry.source))


def _apply_dep_entry_to_merge(entry, merge):
    if merge.skip_deps:
        _skip_dep_entry(entry, merge)
    else:
        target_path = _target_path_for_dep_entry(entry)
        if target_path:
            if _is_excluded_path(target_path, merge):
                _skip_excluded(entry.run_path, target_path, merge)
            else:
                _copy_dep_entry(entry, target_path, merge)
        else:
            _skip_non_project_dep(entry.run_path, merge)


def _skip_dep_entry(entry, merge):
    merge.to_skip.append(
        SkipFile(
            "d",
            entry.run_path,
            _target_path_for_dep_entry(entry),
        )
    )


def _target_path_for_dep_entry(entry):
    if not entry.source_subpath and entry.source.startswith("file:"):
        return entry.source[5:]
    return None


def _copy_dep_entry(entry, project_path, merge):
    merge.to_copy.append(CopyFile("d", entry.run_path, project_path))


def _skip_non_project_dep(path, merge):
    merge.to_skip.append(SkipFile("npd", path, None))


def _skip_unknown(run_path, merge):
    merge.to_skip.append(SkipFile("u", run_path, None))


def _apply_unknown_file_to_merge(path, merge):
    if _is_guildfile(path):
        return
    if not merge.copy_all:
        _skip_other_path(path, merge)
    elif _is_excluded_path(path, merge):
        _skip_excluded(path, path, merge)
    else:
        _copy_other_path(path, merge)


def _is_guildfile(path):
    return path.startswith(".guild")


def _skip_other_path(path, merge):
    merge.to_skip.append(SkipFile("o", path, path))


def _copy_other_path(path, merge):
    merge.to_copy.append(CopyFile("o", path, path))


# def _manifest_index(run):
#     try:
#         m = run_manifest.manfiest_for_run(run)
#     except FileNotFoundError:
#         raise MergeError(f"run manifest does not exist for run {run.id}")
#     else:
#         return _index_for_manifest(m)


# def _index_for_manifest(m):
#     index = {}
#     for args in m:
#         _apply_manifest_entry_to_index(args, index)
#     return index


# def _apply_manifest_entry_to_index(args, index):
#     if args[0] == "s":
#         _apply_sourcecode_entry_to_index(args, index)
#     elif args[0] == "d":
#         _apply_dep_entry_to_index(args, index)


# def _apply_sourcecode_entry_to_index(args, index):
#     run_path, _hash_arg, target_path = args[1:]
#     index[run_path] = MergeFile("s", run_path, target_path)


# def _apply_dep_entry_to_index(args, index):
#     entry = _index_entry_for_manifest_entry(args)
#     index[entry.run_path] = entry


# def _index_entry_for_manifest_entry(args):
#     assert args[0] == "d", args
#     try:
#         return _project_local_merge_file_for_manifest_entry(args)
#     except ValueError:
#         return _NonMergeFile(args[1])


# def _project_local_merge_file_for_manifest_entry(args):
#     if len(args) != 4:
#         raise ValueError()
#     run_path = args[1]
#     src_uri = args[3]
#     if not src_uri.startswith("file:"):
#         raise ValueError()
#     project_path = src_uri[5:]
#     return MergeFile("d", run_path, project_path)


# def _handle_run_file_for_merge(run_path, merge, manifest_index, files):
#     entry = manifest_index.get(run_path) or _maybe_generated_merge_file(run_path)
#     if not isinstance(entry, MergeFile):
#         return
#     merge_file = entry
#     if _merge_file_excluded(merge_file, merge):
#         return
#     files.append(merge_file)


# def _maybe_generated_merge_file(run_path):
#     return MergeFile("g", run_path, run_path) if not _is_guild_path(run_path) else None


# def _is_guild_path(path):
#     return path.startswith(".guild")


# def _merge_file_excluded(merge_file, merge):
#     type = merge_file.type
#     return (
#         (type == "s" and merge.skip_sourcecode)
#         or (type == "d" and merge.skip_deps)
#         or (type == "g" and merge.skip_generated)
#         or _path_excluded(merge_file.target_path, merge.exclude)
#     )


# def _path_excluded(path, exclude_patterns):
#     if not exclude_patterns:
#         return False
#     return any(fnmatch.fnmatch(path, pattern) for pattern in exclude_patterns)


# def apply_run_merge(merge, target_dir, pre_copy=None):
#     run_dir = merge.run.dir
#     for mf in _sorted_merge_files_for_apply(merge.files):
#         src = os.path.join(run_dir, mf.run_path)
#         dest = os.path.join(target_dir, mf.target_path)
#         if pre_copy:
#             try:
#                 pre_copy(merge, mf, src, dest)
#             except StopMerge:
#                 break
#         _copy_file(src, dest)


# def _sorted_merge_files_for_apply(merge_files):
#     return sorted(merge_files, key=lambda mf: mf.target_path)


# def _copy_file(src, dest):
#     try:
#         _shutil_copy(src, dest)
#     except IOError as e:
#         if e.errno != errno.ENOENT:
#             raise
#         os.makedirs(os.path.dirname(dest))
#         _shutil_copy(src, dest)


# def _shutil_copy(src, dest):
#     try:
#         shutil.copy(src, dest)
#     except shutil.SameFileError:
#         pass


# def _prune_overlapping_targets(merge, prefer_nonsource=False):
#     """Removes merge files with overlapping target paths.

#     Overlapping targets may occur because Guild supports two categries
#     of files for merge: source code and non-source code. Non-source
#     code files include dependencies and generated files.

#     `merge.files` may be modified as a result of calling this function.

#     By default, the pruning prefers source code files over non-source
#     code files. In the default case, when a target path exists both as
#     source code and as non-source code, the source code file is
#     retained and the non-source code file is pruned.

#     To prefer non-source code files over source code files, specify
#     `prefer_nonsource=True`.
#     """
#     source_lookup = {mf.target_path for mf in merge.files if mf.type == "s"}
#     nonsource_lookup = {mf.target_path for mf in merge.files if mf.type != "s"}
#     merge.files = [
#         mf
#         for mf in merge.files
#         if _keep_for_prune_overlapping(
#             mf,
#             source_lookup,
#             nonsource_lookup,
#             prefer_nonsource,
#         )
#     ]


# def _keep_for_prune_overlapping(mf, source_lookup, nonsource_lookup, prefer_nonsource):
#     return not (
#         mf.target_path in source_lookup and mf.target_path in nonsource_lookup
#     ) or (mf.type != "s" if prefer_nonsource else mf.type == "s")
